"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = __importStar(require("path"));
var node_core_library_1 = require("@microsoft/node-core-library");
var tsdoc_1 = require("@microsoft/tsdoc");
var api_extractor_model_1 = require("@microsoft/api-extractor-model");
var CustomDocNodeKind_1 = require("../nodes/CustomDocNodeKind");
var DocHeading_1 = require("../nodes/DocHeading");
var DocTable_1 = require("../nodes/DocTable");
var DocEmphasisSpan_1 = require("../nodes/DocEmphasisSpan");
var DocTableRow_1 = require("../nodes/DocTableRow");
var DocTableCell_1 = require("../nodes/DocTableCell");
var DocNoteBox_1 = require("../nodes/DocNoteBox");
var Utilities_1 = require("../utils/Utilities");
var CustomMarkdownEmitter_1 = require("../markdown/CustomMarkdownEmitter");
/**
 * Renders API documentation in the Markdown file format.
 * For more info:  https://en.wikipedia.org/wiki/Markdown
 */
var MarkdownDocumenter = /** @class */ (function () {
    function MarkdownDocumenter(apiModel) {
        this._apiModel = apiModel;
        this._tsdocConfiguration = CustomDocNodeKind_1.CustomDocNodes.configuration;
        this._markdownEmitter = new CustomMarkdownEmitter_1.CustomMarkdownEmitter(this._apiModel);
    }
    MarkdownDocumenter.prototype.generateFiles = function (outputFolder) {
        this._outputFolder = outputFolder;
        console.log();
        this._deleteOldOutputFiles();
        for (var _i = 0, _a = this._apiModel.packages; _i < _a.length; _i++) {
            var apiPackage = _a[_i];
            console.log("Writing " + apiPackage.name + " package");
            this._writeApiItemPage(apiPackage);
        }
    };
    MarkdownDocumenter.prototype._writeApiItemPage = function (apiItem) {
        var _this = this;
        var configuration = this._tsdocConfiguration;
        var output = new tsdoc_1.DocSection({ configuration: this._tsdocConfiguration });
        this._writeBreadcrumb(output, apiItem);
        var scopedName = apiItem.getScopedNameWithinPackage();
        switch (apiItem.kind) {
            case "Class" /* Class */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " class" }));
                break;
            case "Enum" /* Enum */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " enum" }));
                break;
            case "Interface" /* Interface */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " interface" }));
                break;
            case "Method" /* Method */:
            case "MethodSignature" /* MethodSignature */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " method" }));
                break;
            case "Function" /* Function */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " function" }));
                break;
            case "Namespace" /* Namespace */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " namespace" }));
                break;
            case "Package" /* Package */:
                var unscopedPackageName = node_core_library_1.PackageName.getUnscopedName(apiItem.displayName);
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: unscopedPackageName + " package" }));
                break;
            case "Property" /* Property */:
            case "PropertySignature" /* PropertySignature */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " property" }));
                break;
            case "TypeAlias" /* TypeAlias */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " type" }));
                break;
            case "Variable" /* Variable */:
                output.appendNode(new DocHeading_1.DocHeading({ configuration: configuration, title: scopedName + " variable" }));
                break;
            default:
                throw new Error('Unsupported API item kind: ' + apiItem.kind);
        }
        if (api_extractor_model_1.ApiReleaseTagMixin.isBaseClassOf(apiItem)) {
            if (apiItem.releaseTag === api_extractor_model_1.ReleaseTag.Beta) {
                this._writeBetaWarning(output);
            }
        }
        if (apiItem instanceof api_extractor_model_1.ApiDocumentedItem) {
            var tsdocComment = apiItem.tsdocComment;
            if (tsdocComment) {
                if (tsdocComment.deprecatedBlock) {
                    output.appendNode(new DocNoteBox_1.DocNoteBox({ configuration: this._tsdocConfiguration }, [
                        new tsdoc_1.DocParagraph({ configuration: this._tsdocConfiguration }, [
                            new tsdoc_1.DocPlainText({
                                configuration: this._tsdocConfiguration,
                                text: 'Warning: This API is now obsolete. '
                            })
                        ])
                    ].concat(tsdocComment.deprecatedBlock.content.nodes)));
                }
                this._appendSection(output, tsdocComment.summarySection);
            }
        }
        if (apiItem instanceof api_extractor_model_1.ApiDeclaredItem) {
            if (apiItem.excerpt.text.length > 0) {
                output.appendNode(new tsdoc_1.DocParagraph({ configuration: configuration }, [
                    new DocEmphasisSpan_1.DocEmphasisSpan({ configuration: configuration, bold: true }, [
                        new tsdoc_1.DocPlainText({ configuration: configuration, text: 'Signature:' })
                    ])
                ]));
                output.appendNode(new tsdoc_1.DocFencedCode({ configuration: configuration, code: apiItem.getExcerptWithModifiers(), language: 'typescript' }));
            }
        }
        switch (apiItem.kind) {
            case "Class" /* Class */:
                this._writeClassTables(output, apiItem);
                break;
            case "Enum" /* Enum */:
                this._writeEnumTables(output, apiItem);
                break;
            case "Interface" /* Interface */:
                this._writeInterfaceTables(output, apiItem);
                break;
            case "Method" /* Method */:
            case "MethodSignature" /* MethodSignature */:
            case "Function" /* Function */:
                this._writeParameterTables(output, apiItem);
                break;
            case "Namespace" /* Namespace */:
                this._writePackageOrNamespaceTables(output, apiItem);
                break;
            case "Package" /* Package */:
                this._writePackageOrNamespaceTables(output, apiItem);
                break;
            case "Property" /* Property */:
            case "PropertySignature" /* PropertySignature */:
                break;
            case "TypeAlias" /* TypeAlias */:
                break;
            case "Variable" /* Variable */:
                break;
            default:
                throw new Error('Unsupported API item kind: ' + apiItem.kind);
        }
        if (apiItem instanceof api_extractor_model_1.ApiDocumentedItem) {
            var tsdocComment = apiItem.tsdocComment;
            if (tsdocComment) {
                // Write the @remarks block
                if (tsdocComment.remarksBlock) {
                    output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Remarks' }));
                    this._appendSection(output, tsdocComment.remarksBlock.content);
                }
                // Write the @example blocks
                var exampleBlocks = tsdocComment.customBlocks.filter(function (x) { return x.blockTag.tagNameWithUpperCase
                    === tsdoc_1.StandardTags.example.tagNameWithUpperCase; });
                var exampleNumber = 1;
                for (var _i = 0, exampleBlocks_1 = exampleBlocks; _i < exampleBlocks_1.length; _i++) {
                    var exampleBlock = exampleBlocks_1[_i];
                    var heading = exampleBlocks.length > 1 ? "Example " + exampleNumber : 'Example';
                    output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: heading }));
                    this._appendSection(output, exampleBlock.content);
                    ++exampleNumber;
                }
            }
        }
        var filename = path.join(this._outputFolder, this._getFilenameForApiItem(apiItem));
        var stringBuilder = new tsdoc_1.StringBuilder();
        this._markdownEmitter.emit(stringBuilder, output, {
            contextApiItem: apiItem,
            onGetFilenameForApiItem: function (apiItemForFilename) {
                return _this._getLinkFilenameForApiItem(apiItemForFilename);
            }
        });
        node_core_library_1.FileSystem.writeFile(filename, stringBuilder.toString(), {
            convertLineEndings: "\r\n" /* CrLf */
        });
    };
    /**
     * GENERATE PAGE: PACKAGE or NAMESPACE
     */
    MarkdownDocumenter.prototype._writePackageOrNamespaceTables = function (output, apiContainer) {
        var configuration = this._tsdocConfiguration;
        var classesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Class', 'Description']
        });
        var enumerationsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Enumeration', 'Description']
        });
        var functionsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Function', 'Description']
        });
        var interfacesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Interface', 'Description']
        });
        var namespacesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Namespace', 'Description']
        });
        var variablesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Variable', 'Description']
        });
        var typeAliasesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Type Alias', 'Description']
        });
        var apiMembers = apiContainer.kind === "Package" /* Package */ ?
            apiContainer.entryPoints[0].members
            : apiContainer.members;
        for (var _i = 0, apiMembers_1 = apiMembers; _i < apiMembers_1.length; _i++) {
            var apiMember = apiMembers_1[_i];
            var row = new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                this._createTitleCell(apiMember),
                this._createDescriptionCell(apiMember)
            ]);
            switch (apiMember.kind) {
                case "Class" /* Class */:
                    classesTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "Enum" /* Enum */:
                    enumerationsTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "Interface" /* Interface */:
                    interfacesTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "Namespace" /* Namespace */:
                    namespacesTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "Function" /* Function */:
                    functionsTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "TypeAlias" /* TypeAlias */:
                    typeAliasesTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
                case "Variable" /* Variable */:
                    variablesTable.addRow(row);
                    this._writeApiItemPage(apiMember);
                    break;
            }
        }
        if (classesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Classes' }));
            output.appendNode(classesTable);
        }
        if (enumerationsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Enumerations' }));
            output.appendNode(enumerationsTable);
        }
        if (functionsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Functions' }));
            output.appendNode(functionsTable);
        }
        if (interfacesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Interfaces' }));
            output.appendNode(interfacesTable);
        }
        if (namespacesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Namespaces' }));
            output.appendNode(namespacesTable);
        }
        if (variablesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Variables' }));
            output.appendNode(variablesTable);
        }
        if (typeAliasesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Type Aliases' }));
            output.appendNode(typeAliasesTable);
        }
    };
    /**
     * GENERATE PAGE: CLASS
     */
    MarkdownDocumenter.prototype._writeClassTables = function (output, apiClass) {
        var configuration = this._tsdocConfiguration;
        var eventsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Property', 'Modifiers', 'Type', 'Description']
        });
        var propertiesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Property', 'Modifiers', 'Type', 'Description']
        });
        var methodsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Method', 'Modifiers', 'Description']
        });
        for (var _i = 0, _a = apiClass.members; _i < _a.length; _i++) {
            var apiMember = _a[_i];
            switch (apiMember.kind) {
                case "Method" /* Method */: {
                    methodsTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                        this._createTitleCell(apiMember),
                        this._createModifiersCell(apiMember),
                        this._createDescriptionCell(apiMember)
                    ]));
                    this._writeApiItemPage(apiMember);
                    break;
                }
                case "Property" /* Property */: {
                    if (apiMember.isEventProperty) {
                        eventsTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                            this._createTitleCell(apiMember),
                            this._createModifiersCell(apiMember),
                            this._createPropertyTypeCell(apiMember),
                            this._createDescriptionCell(apiMember)
                        ]));
                    }
                    else {
                        propertiesTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                            this._createTitleCell(apiMember),
                            this._createModifiersCell(apiMember),
                            this._createPropertyTypeCell(apiMember),
                            this._createDescriptionCell(apiMember)
                        ]));
                    }
                    this._writeApiItemPage(apiMember);
                    break;
                }
            }
        }
        if (eventsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Events' }));
            output.appendNode(eventsTable);
        }
        if (propertiesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Properties' }));
            output.appendNode(propertiesTable);
        }
        if (methodsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Methods' }));
            output.appendNode(methodsTable);
        }
    };
    /**
     * GENERATE PAGE: ENUM
     */
    MarkdownDocumenter.prototype._writeEnumTables = function (output, apiEnum) {
        var configuration = this._tsdocConfiguration;
        var enumMembersTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Member', 'Value', 'Description']
        });
        for (var _i = 0, _a = apiEnum.members; _i < _a.length; _i++) {
            var apiEnumMember = _a[_i];
            enumMembersTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                new DocTableCell_1.DocTableCell({ configuration: configuration }, [
                    new tsdoc_1.DocParagraph({ configuration: configuration }, [
                        new tsdoc_1.DocPlainText({ configuration: configuration, text: Utilities_1.Utilities.getConciseSignature(apiEnumMember) })
                    ])
                ]),
                new DocTableCell_1.DocTableCell({ configuration: configuration }, [
                    new tsdoc_1.DocParagraph({ configuration: configuration }, [
                        new tsdoc_1.DocCodeSpan({ configuration: configuration, code: apiEnumMember.initializerExcerpt.text })
                    ])
                ]),
                this._createDescriptionCell(apiEnumMember)
            ]));
        }
        if (enumMembersTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Enumeration Members' }));
            output.appendNode(enumMembersTable);
        }
    };
    /**
     * GENERATE PAGE: INTERFACE
     */
    MarkdownDocumenter.prototype._writeInterfaceTables = function (output, apiClass) {
        var configuration = this._tsdocConfiguration;
        var eventsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Property', 'Type', 'Description']
        });
        var propertiesTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Property', 'Type', 'Description']
        });
        var methodsTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Method', 'Description']
        });
        for (var _i = 0, _a = apiClass.members; _i < _a.length; _i++) {
            var apiMember = _a[_i];
            switch (apiMember.kind) {
                case "MethodSignature" /* MethodSignature */: {
                    methodsTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                        this._createTitleCell(apiMember),
                        this._createDescriptionCell(apiMember)
                    ]));
                    this._writeApiItemPage(apiMember);
                    break;
                }
                case "PropertySignature" /* PropertySignature */: {
                    if (apiMember.isEventProperty) {
                        eventsTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                            this._createTitleCell(apiMember),
                            this._createPropertyTypeCell(apiMember),
                            this._createDescriptionCell(apiMember)
                        ]));
                    }
                    else {
                        propertiesTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                            this._createTitleCell(apiMember),
                            this._createPropertyTypeCell(apiMember),
                            this._createDescriptionCell(apiMember)
                        ]));
                    }
                    this._writeApiItemPage(apiMember);
                    break;
                }
            }
        }
        if (eventsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Events' }));
            output.appendNode(eventsTable);
        }
        if (propertiesTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Properties' }));
            output.appendNode(propertiesTable);
        }
        if (methodsTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Methods' }));
            output.appendNode(methodsTable);
        }
    };
    /**
     * GENERATE PAGE: FUNCTION-LIKE
     */
    MarkdownDocumenter.prototype._writeParameterTables = function (output, apiParameterListMixin) {
        var configuration = this._tsdocConfiguration;
        var parametersTable = new DocTable_1.DocTable({ configuration: configuration,
            headerTitles: ['Parameter', 'Type', 'Description']
        });
        for (var _i = 0, _a = apiParameterListMixin.parameters; _i < _a.length; _i++) {
            var apiParameter = _a[_i];
            var parameterDescription = new tsdoc_1.DocSection({ configuration: configuration });
            if (apiParameter.tsdocParamBlock) {
                this._appendSection(parameterDescription, apiParameter.tsdocParamBlock.content);
            }
            parametersTable.addRow(new DocTableRow_1.DocTableRow({ configuration: configuration }, [
                new DocTableCell_1.DocTableCell({ configuration: configuration }, [
                    new tsdoc_1.DocParagraph({ configuration: configuration }, [
                        new tsdoc_1.DocPlainText({ configuration: configuration, text: apiParameter.name })
                    ])
                ]),
                new DocTableCell_1.DocTableCell({ configuration: configuration }, [
                    new tsdoc_1.DocParagraph({ configuration: configuration }, [
                        new tsdoc_1.DocCodeSpan({ configuration: configuration, code: apiParameter.parameterTypeExcerpt.text })
                    ])
                ]),
                new DocTableCell_1.DocTableCell({ configuration: configuration }, parameterDescription.nodes)
            ]));
        }
        if (parametersTable.rows.length > 0) {
            output.appendNode(new DocHeading_1.DocHeading({ configuration: this._tsdocConfiguration, title: 'Parameters' }));
            output.appendNode(parametersTable);
        }
        if (api_extractor_model_1.ApiReturnTypeMixin.isBaseClassOf(apiParameterListMixin)) {
            var returnTypeExcerpt = apiParameterListMixin.returnTypeExcerpt;
            output.appendNode(new tsdoc_1.DocParagraph({ configuration: configuration }, [
                new DocEmphasisSpan_1.DocEmphasisSpan({ configuration: configuration, bold: true }, [
                    new tsdoc_1.DocPlainText({ configuration: configuration, text: 'Returns:' })
                ])
            ]));
            output.appendNode(new tsdoc_1.DocParagraph({ configuration: configuration }, [
                new tsdoc_1.DocCodeSpan({ configuration: configuration, code: returnTypeExcerpt.text.trim() || '(not declared)' })
            ]));
            if (apiParameterListMixin instanceof api_extractor_model_1.ApiDocumentedItem) {
                if (apiParameterListMixin.tsdocComment && apiParameterListMixin.tsdocComment.returnsBlock) {
                    this._appendSection(output, apiParameterListMixin.tsdocComment.returnsBlock.content);
                }
            }
        }
    };
    MarkdownDocumenter.prototype._createTitleCell = function (apiItem) {
        var configuration = this._tsdocConfiguration;
        return new DocTableCell_1.DocTableCell({ configuration: configuration }, [
            new tsdoc_1.DocParagraph({ configuration: configuration }, [
                new tsdoc_1.DocLinkTag({
                    configuration: configuration,
                    tagName: '@link',
                    linkText: Utilities_1.Utilities.getConciseSignature(apiItem),
                    urlDestination: this._getLinkFilenameForApiItem(apiItem)
                })
            ])
        ]);
    };
    /**
     * This generates a DocTableCell for an ApiItem including the summary section and "(BETA)" annotation.
     *
     * @remarks
     * We mostly assume that the input is an ApiDocumentedItem, but it's easier to perform this as a runtime
     * check than to have each caller perform a type cast.
     */
    MarkdownDocumenter.prototype._createDescriptionCell = function (apiItem) {
        var configuration = this._tsdocConfiguration;
        var section = new tsdoc_1.DocSection({ configuration: configuration });
        if (api_extractor_model_1.ApiReleaseTagMixin.isBaseClassOf(apiItem)) {
            if (apiItem.releaseTag === api_extractor_model_1.ReleaseTag.Beta) {
                section.appendNodesInParagraph([
                    new DocEmphasisSpan_1.DocEmphasisSpan({ configuration: configuration, bold: true, italic: true }, [
                        new tsdoc_1.DocPlainText({ configuration: configuration, text: '(BETA)' })
                    ]),
                    new tsdoc_1.DocPlainText({ configuration: configuration, text: ' ' })
                ]);
            }
        }
        if (apiItem instanceof api_extractor_model_1.ApiDocumentedItem) {
            if (apiItem.tsdocComment !== undefined) {
                this._appendAndMergeSection(section, apiItem.tsdocComment.summarySection);
            }
        }
        return new DocTableCell_1.DocTableCell({ configuration: configuration }, section.nodes);
    };
    MarkdownDocumenter.prototype._createModifiersCell = function (apiItem) {
        var configuration = this._tsdocConfiguration;
        var section = new tsdoc_1.DocSection({ configuration: configuration });
        if (api_extractor_model_1.ApiStaticMixin.isBaseClassOf(apiItem)) {
            if (apiItem.isStatic) {
                section.appendNodeInParagraph(new tsdoc_1.DocCodeSpan({ configuration: configuration, code: 'static' }));
            }
        }
        return new DocTableCell_1.DocTableCell({ configuration: configuration }, section.nodes);
    };
    MarkdownDocumenter.prototype._createPropertyTypeCell = function (apiItem) {
        var configuration = this._tsdocConfiguration;
        var section = new tsdoc_1.DocSection({ configuration: configuration });
        if (apiItem instanceof api_extractor_model_1.ApiPropertyItem) {
            section.appendNodeInParagraph(new tsdoc_1.DocCodeSpan({ configuration: configuration, code: apiItem.propertyTypeExcerpt.text }));
        }
        return new DocTableCell_1.DocTableCell({ configuration: configuration }, section.nodes);
    };
    MarkdownDocumenter.prototype._writeBreadcrumb = function (output, apiItem) {
        output.appendNodeInParagraph(new tsdoc_1.DocLinkTag({
            configuration: this._tsdocConfiguration,
            tagName: '@link',
            linkText: 'Home',
            urlDestination: './index'
        }));
        for (var _i = 0, _a = apiItem.getHierarchy(); _i < _a.length; _i++) {
            var hierarchyItem = _a[_i];
            switch (hierarchyItem.kind) {
                case "Model" /* Model */:
                case "EntryPoint" /* EntryPoint */:
                    // We don't show the model as part of the breadcrumb because it is the root-level container.
                    // We don't show the entry point because today API Extractor doesn't support multiple entry points;
                    // this may change in the future.
                    break;
                default:
                    output.appendNodesInParagraph([
                        new tsdoc_1.DocPlainText({
                            configuration: this._tsdocConfiguration,
                            text: ' > '
                        }),
                        new tsdoc_1.DocLinkTag({
                            configuration: this._tsdocConfiguration,
                            tagName: '@link',
                            linkText: hierarchyItem.displayName,
                            urlDestination: this._getLinkFilenameForApiItem(hierarchyItem)
                        })
                    ]);
            }
        }
    };
    MarkdownDocumenter.prototype._writeBetaWarning = function (output) {
        var configuration = this._tsdocConfiguration;
        var betaWarning = 'This API is provided as a preview for developers and may change'
            + ' based on feedback that we receive.  Do not use this API in a production environment.';
        output.appendNode(new DocNoteBox_1.DocNoteBox({ configuration: configuration }, [
            new tsdoc_1.DocParagraph({ configuration: configuration }, [
                new tsdoc_1.DocPlainText({ configuration: configuration, text: betaWarning })
            ])
        ]));
    };
    MarkdownDocumenter.prototype._appendSection = function (output, docSection) {
        for (var _i = 0, _a = docSection.nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            output.appendNode(node);
        }
    };
    MarkdownDocumenter.prototype._appendAndMergeSection = function (output, docSection) {
        var firstNode = true;
        for (var _i = 0, _a = docSection.nodes; _i < _a.length; _i++) {
            var node = _a[_i];
            if (firstNode) {
                if (node.kind === "Paragraph" /* Paragraph */) {
                    output.appendNodesInParagraph(node.getChildNodes());
                    firstNode = false;
                    continue;
                }
            }
            firstNode = false;
            output.appendNode(node);
        }
    };
    MarkdownDocumenter.prototype._getFilenameForApiItem = function (apiItem) {
        var baseName = '';
        for (var _i = 0, _a = apiItem.getHierarchy(); _i < _a.length; _i++) {
            var hierarchyItem = _a[_i];
            // For overloaded methods, add a suffix such as "MyClass.myMethod_2".
            var qualifiedName = hierarchyItem.displayName;
            if (api_extractor_model_1.ApiParameterListMixin.isBaseClassOf(hierarchyItem)) {
                if (hierarchyItem.overloadIndex > 0) {
                    qualifiedName += "_" + hierarchyItem.overloadIndex;
                }
            }
            switch (hierarchyItem.kind) {
                case "Model" /* Model */:
                case "EntryPoint" /* EntryPoint */:
                    break;
                case "Package" /* Package */:
                    baseName = node_core_library_1.PackageName.getUnscopedName(hierarchyItem.displayName);
                    break;
                default:
                    baseName += '.' + qualifiedName;
            }
        }
        return baseName.toLowerCase() + '.md';
    };
    MarkdownDocumenter.prototype._getLinkFilenameForApiItem = function (apiItem) {
        return './' + this._getFilenameForApiItem(apiItem);
    };
    MarkdownDocumenter.prototype._deleteOldOutputFiles = function () {
        console.log('Deleting old output from ' + this._outputFolder);
        node_core_library_1.FileSystem.ensureEmptyFolder(this._outputFolder);
    };
    return MarkdownDocumenter;
}());
exports.MarkdownDocumenter = MarkdownDocumenter;
