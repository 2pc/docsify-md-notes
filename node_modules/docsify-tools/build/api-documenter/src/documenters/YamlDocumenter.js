"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const yaml = require("js-yaml");
const node_core_library_1 = require("@microsoft/node-core-library");
const tsdoc_1 = require("@microsoft/tsdoc");
const api_extractor_model_1 = require("@microsoft/api-extractor-model");
const Utilities_1 = require("../utils/Utilities");
const CustomMarkdownEmitter_1 = require("../markdown/CustomMarkdownEmitter");
const yamlApiSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '..', 'yaml', 'typescript.schema.json'));
/**
 * Writes documentation in the Universal Reference YAML file format, as defined by typescript.schema.json.
 */
class YamlDocumenter {
    constructor(apiModel) {
        this._apiModel = apiModel;
        this._markdownEmitter = new CustomMarkdownEmitter_1.CustomMarkdownEmitter(this._apiModel);
        this._apiItemsByTypeName = new Map();
        this._initApiItemsByTypeName();
    }
    /** @virtual */
    generateFiles(outputFolder) {
        this._outputFolder = outputFolder;
        console.log();
        this._deleteOldOutputFiles();
        for (const apiPackage of this._apiModel.packages) {
            console.log(`Writing ${apiPackage.name} package`);
            this._visitApiItems(apiPackage, undefined);
        }
        this._writeTocFile(this._apiModel.packages);
    }
    /** @virtual */
    onGetTocRoot() {
        return {
            name: 'SharePoint Framework reference',
            href: '~/overview/sharepoint.md',
            items: []
        };
    }
    /** @virtual */
    onCustomizeYamlItem(yamlItem) {
        // (overridden by child class)
    }
    _visitApiItems(apiItem, parentYamlFile) {
        const yamlItem = this._generateYamlItem(apiItem);
        if (!yamlItem) {
            return false;
        }
        this.onCustomizeYamlItem(yamlItem);
        if (this._shouldEmbed(apiItem.kind)) {
            if (!parentYamlFile) {
                throw new node_core_library_1.InternalError('Missing file context');
            }
            parentYamlFile.items.push(yamlItem);
        }
        else {
            const newYamlFile = {
                items: []
            };
            newYamlFile.items.push(yamlItem);
            let children;
            if (apiItem.kind === "Package" /* Package */) {
                // Skip over the entry point, since it's not part of the documentation hierarchy
                children = apiItem.members[0].members;
            }
            else {
                children = apiItem.members;
            }
            const flattenedChildren = this._flattenNamespaces(children);
            for (const child of flattenedChildren) {
                if (child instanceof api_extractor_model_1.ApiDocumentedItem) {
                    if (this._visitApiItems(child, newYamlFile)) {
                        if (!yamlItem.children) {
                            yamlItem.children = [];
                        }
                        yamlItem.children.push(this._getUid(child));
                    }
                }
            }
            const yamlFilePath = this._getYamlFilePath(apiItem);
            if (apiItem.kind === "Package" /* Package */) {
                console.log('Writing ' + yamlFilePath);
            }
            this._writeYamlFile(newYamlFile, yamlFilePath, 'UniversalReference', yamlApiSchema);
            if (parentYamlFile) {
                if (!parentYamlFile.references) {
                    parentYamlFile.references = [];
                }
                parentYamlFile.references.push({
                    uid: this._getUid(apiItem),
                    name: this._getYamlItemName(apiItem)
                });
            }
        }
        return true;
    }
    // Since the YAML schema does not yet support nested namespaces, we simply omit them from
    // the tree.  However, _getYamlItemName() will show the namespace.
    _flattenNamespaces(items) {
        const flattened = [];
        for (const item of items) {
            if (item.kind === "Namespace" /* Namespace */) {
                flattened.push(...this._flattenNamespaces(item.members));
            }
            else {
                flattened.push(item);
            }
        }
        return flattened;
    }
    /**
     * Write the table of contents
     */
    _writeTocFile(apiItems) {
        const tocFile = {
            items: []
        };
        const rootItem = this.onGetTocRoot();
        tocFile.items.push(rootItem);
        rootItem.items.push(...this._buildTocItems(apiItems));
        const tocFilePath = path.join(this._outputFolder, 'toc.yml');
        console.log('Writing ' + tocFilePath);
        this._writeYamlFile(tocFile, tocFilePath, '', undefined);
    }
    _buildTocItems(apiItems) {
        const tocItems = [];
        for (const apiItem of apiItems) {
            let tocItem;
            if (apiItem.kind === "Namespace" /* Namespace */) {
                // Namespaces don't have nodes yet
                tocItem = {
                    name: apiItem.displayName
                };
            }
            else {
                if (this._shouldEmbed(apiItem.kind)) {
                    // Don't generate table of contents items for embedded definitions
                    continue;
                }
                if (apiItem.kind === "Package" /* Package */) {
                    tocItem = {
                        name: node_core_library_1.PackageName.getUnscopedName(apiItem.displayName),
                        uid: this._getUid(apiItem)
                    };
                }
                else {
                    tocItem = {
                        name: apiItem.displayName,
                        uid: this._getUid(apiItem)
                    };
                }
            }
            tocItems.push(tocItem);
            let children;
            if (apiItem.kind === "Package" /* Package */) {
                // Skip over the entry point, since it's not part of the documentation hierarchy
                children = apiItem.members[0].members;
            }
            else {
                children = apiItem.members;
            }
            const childItems = this._buildTocItems(children);
            if (childItems.length > 0) {
                tocItem.items = childItems;
            }
        }
        return tocItems;
    }
    _shouldEmbed(apiItemKind) {
        switch (apiItemKind) {
            case "Class" /* Class */:
            case "Package" /* Package */:
            case "Interface" /* Interface */:
            case "Enum" /* Enum */:
                return false;
        }
        return true;
    }
    _generateYamlItem(apiItem) {
        // Filter out known items that are not yet supported
        switch (apiItem.kind) {
            case "CallSignature" /* CallSignature */:
            case "ConstructSignature" /* ConstructSignature */:
            case "IndexSignature" /* IndexSignature */:
            case "TypeAlias" /* TypeAlias */:
            case "Variable" /* Variable */:
                return undefined;
        }
        const yamlItem = {};
        yamlItem.uid = this._getUid(apiItem);
        if (apiItem.tsdocComment) {
            const tsdocComment = apiItem.tsdocComment;
            if (tsdocComment.summarySection) {
                const summary = this._renderMarkdown(tsdocComment.summarySection, apiItem);
                if (summary) {
                    yamlItem.summary = summary;
                }
            }
            if (tsdocComment.remarksBlock) {
                const remarks = this._renderMarkdown(tsdocComment.remarksBlock.content, apiItem);
                if (remarks) {
                    yamlItem.remarks = remarks;
                }
            }
            if (tsdocComment.deprecatedBlock) {
                const deprecatedMessage = this._renderMarkdown(tsdocComment.deprecatedBlock.content, apiItem);
                if (deprecatedMessage.length > 0) {
                    yamlItem.deprecated = { content: deprecatedMessage };
                }
            }
        }
        if (api_extractor_model_1.ApiReleaseTagMixin.isBaseClassOf(apiItem)) {
            if (apiItem.releaseTag === api_extractor_model_1.ReleaseTag.Beta) {
                yamlItem.isPreview = true;
            }
        }
        yamlItem.name = this._getYamlItemName(apiItem);
        yamlItem.fullName = yamlItem.name;
        yamlItem.langs = ['typeScript'];
        switch (apiItem.kind) {
            case "Enum" /* Enum */:
                yamlItem.type = 'enum';
                break;
            case "EnumMember" /* EnumMember */:
                yamlItem.type = 'field';
                const enumMember = apiItem;
                if (enumMember.initializerExcerpt.text.length > 0) {
                    yamlItem.numericValue = enumMember.initializerExcerpt.text;
                }
                break;
            case "Class" /* Class */:
                yamlItem.type = 'class';
                this._populateYamlClassOrInterface(yamlItem, apiItem);
                break;
            case "Interface" /* Interface */:
                yamlItem.type = 'interface';
                this._populateYamlClassOrInterface(yamlItem, apiItem);
                break;
            case "Method" /* Method */:
            case "MethodSignature" /* MethodSignature */:
                yamlItem.type = 'method';
                this._populateYamlFunctionLike(yamlItem, apiItem);
                break;
            case "Constructor" /* Constructor */:
                yamlItem.type = 'constructor';
                this._populateYamlFunctionLike(yamlItem, apiItem);
                break;
            case "Package" /* Package */:
                yamlItem.type = 'package';
                break;
            case "Property" /* Property */:
            case "PropertySignature" /* PropertySignature */:
                const apiProperty = apiItem;
                if (apiProperty.isEventProperty) {
                    yamlItem.type = 'event';
                }
                else {
                    yamlItem.type = 'property';
                }
                this._populateYamlProperty(yamlItem, apiProperty);
                break;
            case "Function" /* Function */:
                yamlItem.type = 'function';
                this._populateYamlFunctionLike(yamlItem, apiItem);
                break;
            default:
                throw new Error('Unimplemented item kind: ' + apiItem.kind);
        }
        if (apiItem.kind !== "Package" /* Package */ && !this._shouldEmbed(apiItem.kind)) {
            const associatedPackage = apiItem.getAssociatedPackage();
            if (!associatedPackage) {
                throw new Error('Unable to determine associated package for ' + apiItem.displayName);
            }
            yamlItem.package = this._getUid(associatedPackage);
        }
        return yamlItem;
    }
    _populateYamlClassOrInterface(yamlItem, apiItem) {
        if (apiItem instanceof api_extractor_model_1.ApiClass) {
            if (apiItem.extendsType) {
                yamlItem.extends = [this._linkToUidIfPossible(apiItem.extendsType.excerpt.text)];
            }
            if (apiItem.implementsTypes.length > 0) {
                yamlItem.implements = [];
                for (const implementsType of apiItem.implementsTypes) {
                    yamlItem.implements.push(this._linkToUidIfPossible(implementsType.excerpt.text));
                }
            }
        }
        else if (apiItem instanceof api_extractor_model_1.ApiInterface) {
            if (apiItem.extendsTypes.length > 0) {
                yamlItem.extends = [];
                for (const extendsType of apiItem.extendsTypes) {
                    yamlItem.extends.push(this._linkToUidIfPossible(extendsType.excerpt.text));
                }
            }
        }
        if (apiItem.tsdocComment) {
            if (apiItem.tsdocComment.modifierTagSet.isSealed()) {
                let sealedMessage;
                if (apiItem.kind === "Class" /* Class */) {
                    sealedMessage = 'This class is marked as `@sealed`. Subclasses should not extend it.';
                }
                else {
                    sealedMessage = 'This interface is marked as `@sealed`. Other interfaces should not extend it.';
                }
                if (!yamlItem.remarks) {
                    yamlItem.remarks = sealedMessage;
                }
                else {
                    yamlItem.remarks = sealedMessage + '\n\n' + yamlItem.remarks;
                }
            }
        }
    }
    _populateYamlFunctionLike(yamlItem, apiItem) {
        const syntax = {
            content: apiItem.getExcerptWithModifiers()
        };
        yamlItem.syntax = syntax;
        if (api_extractor_model_1.ApiReturnTypeMixin.isBaseClassOf(apiItem)) {
            const returnType = this._linkToUidIfPossible(apiItem.returnTypeExcerpt.text);
            let returnDescription = '';
            if (apiItem.tsdocComment && apiItem.tsdocComment.returnsBlock) {
                returnDescription = this._renderMarkdown(apiItem.tsdocComment.returnsBlock.content, apiItem);
                // temporary workaround for people who mistakenly add a hyphen, e.g. "@returns - blah"
                returnDescription = returnDescription.replace(/^\s*-\s+/, '');
            }
            if (returnType || returnDescription) {
                syntax.return = {
                    type: [returnType],
                    description: returnDescription
                };
            }
        }
        const parameters = [];
        for (const apiParameter of apiItem.parameters) {
            let parameterDescription = '';
            if (apiParameter.tsdocParamBlock) {
                parameterDescription = this._renderMarkdown(apiParameter.tsdocParamBlock.content, apiItem);
            }
            parameters.push({
                id: apiParameter.name,
                description: parameterDescription,
                type: [this._linkToUidIfPossible(apiParameter.parameterTypeExcerpt.text)]
            });
        }
        if (parameters.length) {
            syntax.parameters = parameters;
        }
    }
    _populateYamlProperty(yamlItem, apiItem) {
        const syntax = {
            content: apiItem.getExcerptWithModifiers()
        };
        yamlItem.syntax = syntax;
        if (apiItem.propertyTypeExcerpt.text) {
            syntax.return = {
                type: [this._linkToUidIfPossible(apiItem.propertyTypeExcerpt.text)]
            };
        }
    }
    _renderMarkdown(docSection, contextApiItem) {
        const stringBuilder = new tsdoc_1.StringBuilder();
        this._markdownEmitter.emit(stringBuilder, docSection, {
            contextApiItem,
            onGetFilenameForApiItem: (apiItem) => {
                // NOTE: GitHub's markdown renderer does not resolve relative hyperlinks correctly
                // unless they start with "./" or "../".
                return `xref:${this._getUid(apiItem)}`;
            }
        });
        return stringBuilder.toString().trim();
    }
    _writeYamlFile(dataObject, filePath, yamlMimeType, schema) {
        node_core_library_1.JsonFile.validateNoUndefinedMembers(dataObject);
        let stringified = yaml.safeDump(dataObject, {
            lineWidth: 120
        });
        if (yamlMimeType) {
            stringified = `### YamlMime:${yamlMimeType}\n` + stringified;
        }
        node_core_library_1.FileSystem.writeFile(filePath, stringified, {
            convertLineEndings: "\r\n" /* CrLf */,
            ensureFolderExists: true
        });
        if (schema) {
            schema.validateObject(dataObject, filePath);
        }
    }
    /**
     * Calculate the DocFX "uid" for the ApiItem
     * Example:  node-core-library.JsonFile.load
     */
    _getUid(apiItem) {
        let result = '';
        for (const hierarchyItem of apiItem.getHierarchy()) {
            // For overloaded methods, add a suffix such as "MyClass.myMethod_2".
            let qualifiedName = hierarchyItem.displayName;
            if (api_extractor_model_1.ApiParameterListMixin.isBaseClassOf(hierarchyItem)) {
                if (hierarchyItem.overloadIndex > 0) {
                    qualifiedName += `_${hierarchyItem.overloadIndex}`;
                }
            }
            switch (hierarchyItem.kind) {
                case "Model" /* Model */:
                case "EntryPoint" /* EntryPoint */:
                    break;
                case "Package" /* Package */:
                    result += node_core_library_1.PackageName.getUnscopedName(hierarchyItem.displayName);
                    break;
                default:
                    result += '.';
                    result += qualifiedName;
                    break;
            }
        }
        return result;
    }
    /**
     * Initialize the _apiItemsByTypeName data structure.
     */
    _initApiItemsByTypeName() {
        // Collect the _apiItemsByTypeName table
        const ambiguousNames = new Set();
        this._initApiItemsByTypeNameRecursive(this._apiModel, ambiguousNames);
        // Remove the ambiguous matches
        for (const ambiguousName of ambiguousNames) {
            this._apiItemsByTypeName.delete(ambiguousName);
        }
    }
    /**
     * Helper for _initApiItemsByTypeName()
     */
    _initApiItemsByTypeNameRecursive(apiItem, ambiguousNames) {
        switch (apiItem.kind) {
            case "Class" /* Class */:
            case "Enum" /* Enum */:
            case "Interface" /* Interface */:
                // Attempt to register both the fully qualified name and the short name
                const namesForType = [apiItem.displayName];
                // Note that nameWithDot cannot conflict with apiItem.name (because apiItem.name
                // cannot contain a dot)
                const nameWithDot = this._getTypeNameWithDot(apiItem);
                if (nameWithDot) {
                    namesForType.push(nameWithDot);
                }
                // Register all names
                for (const typeName of namesForType) {
                    if (ambiguousNames.has(typeName)) {
                        break;
                    }
                    if (this._apiItemsByTypeName.has(typeName)) {
                        // We saw this name before, so it's an ambiguous match
                        ambiguousNames.add(typeName);
                        break;
                    }
                    this._apiItemsByTypeName.set(typeName, apiItem);
                }
                break;
        }
        // Recurse container members
        if (api_extractor_model_1.ApiItemContainerMixin.isBaseClassOf(apiItem)) {
            for (const apiMember of apiItem.members) {
                this._initApiItemsByTypeNameRecursive(apiMember, ambiguousNames);
            }
        }
    }
    /**
     * This is a temporary workaround to enable limited autolinking of API item types
     * until the YAML file format is enhanced to support general hyperlinks.
     * @remarks
     * In the current version, fields such as IApiProperty.type allow either:
     * (1) a UID identifier such as "node-core-library.JsonFile" which will be rendered
     * as a hyperlink to that type name, or (2) a block of freeform text that must not
     * contain any Markdown links.  The _substituteUidForSimpleType() function assumes
     * it is given #2 but substitutes #1 if the name can be matched to a ApiItem.
     */
    _linkToUidIfPossible(typeName) {
        // Note that typeName might be a _getTypeNameWithDot() name or it might be a simple class name
        const apiItem = this._apiItemsByTypeName.get(typeName.trim());
        if (apiItem) {
            // Substitute the UID
            return this._getUid(apiItem);
        }
        return typeName;
    }
    /**
     * If the apiItem represents a scoped name such as "my-library#MyNamespace.MyClass",
     * this returns a string such as "MyNamespace.MyClass".  If the result would not
     * have at least one dot in it, then undefined is returned.
     */
    _getTypeNameWithDot(apiItem) {
        const result = apiItem.getScopedNameWithinPackage();
        if (result.indexOf('.') >= 0) {
            return result;
        }
        return undefined;
    }
    _getYamlItemName(apiItem) {
        if (apiItem.parent && apiItem.parent.kind === "Namespace" /* Namespace */) {
            // For members a namespace, show the full name excluding the package part:
            // Example: excel.Excel.Binding --> Excel.Binding
            return this._getUid(apiItem).replace(/^[^.]+\./, '');
        }
        return Utilities_1.Utilities.getConciseSignature(apiItem);
    }
    _getYamlFilePath(apiItem) {
        let result = '';
        for (const current of apiItem.getHierarchy()) {
            switch (current.kind) {
                case "Model" /* Model */:
                case "EntryPoint" /* EntryPoint */:
                    break;
                case "Package" /* Package */:
                    result += node_core_library_1.PackageName.getUnscopedName(current.displayName);
                    break;
                default:
                    if (current.parent && current.parent.kind === "EntryPoint" /* EntryPoint */) {
                        result += '/';
                    }
                    else {
                        result += '.';
                    }
                    result += current.displayName;
                    break;
            }
        }
        return path.join(this._outputFolder, result.toLowerCase() + '.yml');
    }
    _deleteOldOutputFiles() {
        console.log('Deleting old output from ' + this._outputFolder);
        node_core_library_1.FileSystem.ensureEmptyFolder(this._outputFolder);
    }
}
exports.YamlDocumenter = YamlDocumenter;
